Created by PLY version 3.4 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> classes
Rule 2     classes -> classes class
Rule 3     classes -> empty
Rule 4     class -> CLASS TYPEID inherits { features } ;
Rule 5     inherits -> INHERITS TYPEID
Rule 6     inherits -> empty
Rule 7     features -> features feature
Rule 8     features -> empty
Rule 9     feature -> method ;
Rule 10    feature -> attr ;
Rule 11    method -> OBJECTID ( formals ) : TYPEID { expr }
Rule 12    attr -> OBJECTID : TYPEID
Rule 13    attr -> OBJECTID : TYPEID ASSIGN expr
Rule 14    formals -> formal more_formals
Rule 15    formals -> empty
Rule 16    formal -> OBJECTID : TYPEID
Rule 17    more_formals -> , formal more_formals
Rule 18    more_formals -> empty
Rule 19    expr -> assign
Rule 20    expr -> dispatch
Rule 21    expr -> static_dispatch
Rule 22    expr -> if_expr
Rule 23    expr -> while_expr
Rule 24    expr -> block
Rule 25    expr -> LET let_list IN expr
Rule 26    expr -> case_expr
Rule 27    expr -> bin_op
Rule 28    expr -> un_op
Rule 29    expr -> parens
Rule 30    expr -> ref
Rule 31    assign -> OBJECTID ASSIGN expr
Rule 32    dispatch -> expr . OBJECTID ( actuals )
Rule 33    dispatch -> OBJECTID ( actuals )
Rule 34    static_dispatch -> expr @ TYPEID . OBJECTID ( actuals )
Rule 35    actuals -> expr more_actuals
Rule 36    more_actuals -> , expr more_actuals
Rule 37    more_actuals -> empty
Rule 38    if_expr -> IF expr THEN expr ELSE expr FI
Rule 39    if_expr -> IF expr THEN expr FI
Rule 40    while_expr -> WHILE expr LOOP expr POOL
Rule 41    block -> { expr_list }
Rule 42    parens -> ( expr )
Rule 43    expr_list -> expr ; expr_list
Rule 44    expr_list -> empty
Rule 45    case_expr -> CASE expr OF case_list ESAC
Rule 46    case_list -> case case_list
Rule 47    case_list -> empty
Rule 48    let_list -> OBJECTID : TYPEID more_let
Rule 49    let_list -> OBJECTID : TYPEID ASSIGN expr more_let
Rule 50    more_let -> , OBJECTID : TYPEID more_let
Rule 51    more_let -> , OBJECTID : TYPEID ASSIGN expr more_let
Rule 52    more_let -> empty
Rule 53    case -> OBJECTID : TYPEID DARROW expr ;
Rule 54    bin_op -> plus
Rule 55    bin_op -> sub
Rule 56    bin_op -> mul
Rule 57    bin_op -> div
Rule 58    bin_op -> lt
Rule 59    bin_op -> le
Rule 60    bin_op -> eq
Rule 61    plus -> expr + expr
Rule 62    sub -> expr - expr
Rule 63    mul -> expr * expr
Rule 64    div -> expr / expr
Rule 65    lt -> expr < expr
Rule 66    le -> expr LE expr
Rule 67    eq -> expr = expr
Rule 68    un_op -> neg
Rule 69    un_op -> new
Rule 70    un_op -> isvoid
Rule 71    un_op -> comp
Rule 72    neg -> ~ expr
Rule 73    new -> NEW expr
Rule 74    isvoid -> ISVOID expr
Rule 75    comp -> NOT expr
Rule 76    ref -> object
Rule 77    ref -> int
Rule 78    ref -> string
Rule 79    ref -> bool
Rule 80    object -> OBJECTID
Rule 81    string -> STR_CONST
Rule 82    int -> INT_CONST
Rule 83    bool -> BOOL_CONST
Rule 84    empty -> <empty>

Terminals, with rules where they appear

(                    : 11 32 33 34 42
)                    : 11 32 33 34 42
*                    : 63
+                    : 61
,                    : 17 36 50 51
-                    : 62
.                    : 32 34
/                    : 64
:                    : 11 12 13 16 48 49 50 51 53
;                    : 4 9 10 43 53
<                    : 65
=                    : 67
@                    : 34
ASSIGN               : 13 31 49 51
BOOL_CONST           : 83
CASE                 : 45
CLASS                : 4
DARROW               : 53
ELSE                 : 38
ESAC                 : 45
FI                   : 38 39
IF                   : 38 39
IN                   : 25
INHERITS             : 5
INT_CONST            : 82
ISVOID               : 74
LE                   : 66
LET                  : 25
LOOP                 : 40
NEW                  : 73
NOT                  : 75
OBJECTID             : 11 12 13 16 31 32 33 34 48 49 50 51 53 80
OF                   : 45
POOL                 : 40
STR_CONST            : 81
THEN                 : 38 39
TYPEID               : 4 5 11 12 13 16 34 48 49 50 51 53
WHILE                : 40
error                : 
{                    : 4 11 41
}                    : 4 11 41
~                    : 72

Nonterminals, with rules where they appear

actuals              : 32 33 34
assign               : 19
attr                 : 10
bin_op               : 27
block                : 24
bool                 : 79
case                 : 46
case_expr            : 26
case_list            : 45 46
class                : 2
classes              : 1 2
comp                 : 71
dispatch             : 20
div                  : 57
empty                : 3 6 8 15 18 37 44 47 52
eq                   : 60
expr                 : 11 13 25 31 32 34 35 36 38 38 38 39 39 40 40 42 43 45 49 51 53 61 61 62 62 63 63 64 64 65 65 66 66 67 67 72 73 74 75
expr_list            : 41 43
feature              : 7
features             : 4 7
formal               : 14 17
formals              : 11
if_expr              : 22
inherits             : 4
int                  : 77
isvoid               : 70
le                   : 59
let_list             : 25
lt                   : 58
method               : 9
more_actuals         : 35 36
more_formals         : 14 17
more_let             : 48 49 50 51
mul                  : 56
neg                  : 68
new                  : 69
object               : 76
parens               : 29
plus                 : 54
program              : 0
ref                  : 30
static_dispatch      : 21
string               : 78
sub                  : 55
un_op                : 28
while_expr           : 23

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . classes
    (2) classes -> . classes class
    (3) classes -> . empty
    (84) empty -> .

    CLASS           reduce using rule 84 (empty -> .)
    $end            reduce using rule 84 (empty -> .)

    classes                        shift and go to state 1
    program                        shift and go to state 2
    empty                          shift and go to state 3

state 1

    (1) program -> classes .
    (2) classes -> classes . class
    (4) class -> . CLASS TYPEID inherits { features } ;

    $end            reduce using rule 1 (program -> classes .)
    CLASS           shift and go to state 4

    class                          shift and go to state 5

state 2

    (0) S' -> program .



state 3

    (3) classes -> empty .

    CLASS           reduce using rule 3 (classes -> empty .)
    $end            reduce using rule 3 (classes -> empty .)


state 4

    (4) class -> CLASS . TYPEID inherits { features } ;

    TYPEID          shift and go to state 6


state 5

    (2) classes -> classes class .

    CLASS           reduce using rule 2 (classes -> classes class .)
    $end            reduce using rule 2 (classes -> classes class .)


state 6

    (4) class -> CLASS TYPEID . inherits { features } ;
    (5) inherits -> . INHERITS TYPEID
    (6) inherits -> . empty
    (84) empty -> .

    INHERITS        shift and go to state 8
    {               reduce using rule 84 (empty -> .)

    inherits                       shift and go to state 7
    empty                          shift and go to state 9

state 7

    (4) class -> CLASS TYPEID inherits . { features } ;

    {               shift and go to state 10


state 8

    (5) inherits -> INHERITS . TYPEID

    TYPEID          shift and go to state 11


state 9

    (6) inherits -> empty .

    {               reduce using rule 6 (inherits -> empty .)


state 10

    (4) class -> CLASS TYPEID inherits { . features } ;
    (7) features -> . features feature
    (8) features -> . empty
    (84) empty -> .

    }               reduce using rule 84 (empty -> .)
    OBJECTID        reduce using rule 84 (empty -> .)

    features                       shift and go to state 12
    empty                          shift and go to state 13

state 11

    (5) inherits -> INHERITS TYPEID .

    {               reduce using rule 5 (inherits -> INHERITS TYPEID .)


state 12

    (4) class -> CLASS TYPEID inherits { features . } ;
    (7) features -> features . feature
    (9) feature -> . method ;
    (10) feature -> . attr ;
    (11) method -> . OBJECTID ( formals ) : TYPEID { expr }
    (12) attr -> . OBJECTID : TYPEID
    (13) attr -> . OBJECTID : TYPEID ASSIGN expr

    }               shift and go to state 17
    OBJECTID        shift and go to state 14

    attr                           shift and go to state 18
    feature                        shift and go to state 15
    method                         shift and go to state 16

state 13

    (8) features -> empty .

    }               reduce using rule 8 (features -> empty .)
    OBJECTID        reduce using rule 8 (features -> empty .)


state 14

    (11) method -> OBJECTID . ( formals ) : TYPEID { expr }
    (12) attr -> OBJECTID . : TYPEID
    (13) attr -> OBJECTID . : TYPEID ASSIGN expr

    (               shift and go to state 19
    :               shift and go to state 20


state 15

    (7) features -> features feature .

    }               reduce using rule 7 (features -> features feature .)
    OBJECTID        reduce using rule 7 (features -> features feature .)


state 16

    (9) feature -> method . ;

    ;               shift and go to state 21


state 17

    (4) class -> CLASS TYPEID inherits { features } . ;

    ;               shift and go to state 22


state 18

    (10) feature -> attr . ;

    ;               shift and go to state 23


state 19

    (11) method -> OBJECTID ( . formals ) : TYPEID { expr }
    (14) formals -> . formal more_formals
    (15) formals -> . empty
    (16) formal -> . OBJECTID : TYPEID
    (84) empty -> .

    OBJECTID        shift and go to state 24
    )               reduce using rule 84 (empty -> .)

    formal                         shift and go to state 25
    empty                          shift and go to state 26
    formals                        shift and go to state 27

state 20

    (12) attr -> OBJECTID : . TYPEID
    (13) attr -> OBJECTID : . TYPEID ASSIGN expr

    TYPEID          shift and go to state 28


state 21

    (9) feature -> method ; .

    }               reduce using rule 9 (feature -> method ; .)
    OBJECTID        reduce using rule 9 (feature -> method ; .)


state 22

    (4) class -> CLASS TYPEID inherits { features } ; .

    CLASS           reduce using rule 4 (class -> CLASS TYPEID inherits { features } ; .)
    $end            reduce using rule 4 (class -> CLASS TYPEID inherits { features } ; .)


state 23

    (10) feature -> attr ; .

    }               reduce using rule 10 (feature -> attr ; .)
    OBJECTID        reduce using rule 10 (feature -> attr ; .)


state 24

    (16) formal -> OBJECTID . : TYPEID

    :               shift and go to state 29


state 25

    (14) formals -> formal . more_formals
    (17) more_formals -> . , formal more_formals
    (18) more_formals -> . empty
    (84) empty -> .

    ,               shift and go to state 31
    )               reduce using rule 84 (empty -> .)

    empty                          shift and go to state 30
    more_formals                   shift and go to state 32

state 26

    (15) formals -> empty .

    )               reduce using rule 15 (formals -> empty .)


state 27

    (11) method -> OBJECTID ( formals . ) : TYPEID { expr }

    )               shift and go to state 33


state 28

    (12) attr -> OBJECTID : TYPEID .
    (13) attr -> OBJECTID : TYPEID . ASSIGN expr

    ;               reduce using rule 12 (attr -> OBJECTID : TYPEID .)
    ASSIGN          shift and go to state 34


state 29

    (16) formal -> OBJECTID : . TYPEID

    TYPEID          shift and go to state 35


state 30

    (18) more_formals -> empty .

    )               reduce using rule 18 (more_formals -> empty .)


state 31

    (17) more_formals -> , . formal more_formals
    (16) formal -> . OBJECTID : TYPEID

    OBJECTID        shift and go to state 24

    formal                         shift and go to state 36

state 32

    (14) formals -> formal more_formals .

    )               reduce using rule 14 (formals -> formal more_formals .)


state 33

    (11) method -> OBJECTID ( formals ) . : TYPEID { expr }

    :               shift and go to state 37


state 34

    (13) attr -> OBJECTID : TYPEID ASSIGN . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 71
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 35

    (16) formal -> OBJECTID : TYPEID .

    ,               reduce using rule 16 (formal -> OBJECTID : TYPEID .)
    )               reduce using rule 16 (formal -> OBJECTID : TYPEID .)


state 36

    (17) more_formals -> , formal . more_formals
    (17) more_formals -> . , formal more_formals
    (18) more_formals -> . empty
    (84) empty -> .

    ,               shift and go to state 31
    )               reduce using rule 84 (empty -> .)

    empty                          shift and go to state 30
    more_formals                   shift and go to state 79

state 37

    (11) method -> OBJECTID ( formals ) : . TYPEID { expr }

    TYPEID          shift and go to state 80


state 38

    (81) string -> STR_CONST .

    POOL            reduce using rule 81 (string -> STR_CONST .)
    .               reduce using rule 81 (string -> STR_CONST .)
    @               reduce using rule 81 (string -> STR_CONST .)
    +               reduce using rule 81 (string -> STR_CONST .)
    -               reduce using rule 81 (string -> STR_CONST .)
    *               reduce using rule 81 (string -> STR_CONST .)
    /               reduce using rule 81 (string -> STR_CONST .)
    <               reduce using rule 81 (string -> STR_CONST .)
    LE              reduce using rule 81 (string -> STR_CONST .)
    =               reduce using rule 81 (string -> STR_CONST .)
    ;               reduce using rule 81 (string -> STR_CONST .)
    LOOP            reduce using rule 81 (string -> STR_CONST .)
    OF              reduce using rule 81 (string -> STR_CONST .)
    )               reduce using rule 81 (string -> STR_CONST .)
    THEN            reduce using rule 81 (string -> STR_CONST .)
    ,               reduce using rule 81 (string -> STR_CONST .)
    }               reduce using rule 81 (string -> STR_CONST .)
    ELSE            reduce using rule 81 (string -> STR_CONST .)
    FI              reduce using rule 81 (string -> STR_CONST .)
    IN              reduce using rule 81 (string -> STR_CONST .)


state 39

    (26) expr -> case_expr .

    .               reduce using rule 26 (expr -> case_expr .)
    @               reduce using rule 26 (expr -> case_expr .)
    +               reduce using rule 26 (expr -> case_expr .)
    -               reduce using rule 26 (expr -> case_expr .)
    *               reduce using rule 26 (expr -> case_expr .)
    /               reduce using rule 26 (expr -> case_expr .)
    <               reduce using rule 26 (expr -> case_expr .)
    LE              reduce using rule 26 (expr -> case_expr .)
    =               reduce using rule 26 (expr -> case_expr .)
    ;               reduce using rule 26 (expr -> case_expr .)
    LOOP            reduce using rule 26 (expr -> case_expr .)
    OF              reduce using rule 26 (expr -> case_expr .)
    )               reduce using rule 26 (expr -> case_expr .)
    THEN            reduce using rule 26 (expr -> case_expr .)
    ,               reduce using rule 26 (expr -> case_expr .)
    }               reduce using rule 26 (expr -> case_expr .)
    POOL            reduce using rule 26 (expr -> case_expr .)
    ELSE            reduce using rule 26 (expr -> case_expr .)
    FI              reduce using rule 26 (expr -> case_expr .)
    IN              reduce using rule 26 (expr -> case_expr .)


state 40

    (77) ref -> int .

    .               reduce using rule 77 (ref -> int .)
    @               reduce using rule 77 (ref -> int .)
    +               reduce using rule 77 (ref -> int .)
    -               reduce using rule 77 (ref -> int .)
    *               reduce using rule 77 (ref -> int .)
    /               reduce using rule 77 (ref -> int .)
    <               reduce using rule 77 (ref -> int .)
    LE              reduce using rule 77 (ref -> int .)
    =               reduce using rule 77 (ref -> int .)
    ;               reduce using rule 77 (ref -> int .)
    LOOP            reduce using rule 77 (ref -> int .)
    OF              reduce using rule 77 (ref -> int .)
    )               reduce using rule 77 (ref -> int .)
    THEN            reduce using rule 77 (ref -> int .)
    ,               reduce using rule 77 (ref -> int .)
    }               reduce using rule 77 (ref -> int .)
    POOL            reduce using rule 77 (ref -> int .)
    ELSE            reduce using rule 77 (ref -> int .)
    FI              reduce using rule 77 (ref -> int .)
    IN              reduce using rule 77 (ref -> int .)


state 41

    (20) expr -> dispatch .

    .               reduce using rule 20 (expr -> dispatch .)
    @               reduce using rule 20 (expr -> dispatch .)
    +               reduce using rule 20 (expr -> dispatch .)
    -               reduce using rule 20 (expr -> dispatch .)
    *               reduce using rule 20 (expr -> dispatch .)
    /               reduce using rule 20 (expr -> dispatch .)
    <               reduce using rule 20 (expr -> dispatch .)
    LE              reduce using rule 20 (expr -> dispatch .)
    =               reduce using rule 20 (expr -> dispatch .)
    ;               reduce using rule 20 (expr -> dispatch .)
    LOOP            reduce using rule 20 (expr -> dispatch .)
    OF              reduce using rule 20 (expr -> dispatch .)
    )               reduce using rule 20 (expr -> dispatch .)
    THEN            reduce using rule 20 (expr -> dispatch .)
    ,               reduce using rule 20 (expr -> dispatch .)
    }               reduce using rule 20 (expr -> dispatch .)
    POOL            reduce using rule 20 (expr -> dispatch .)
    ELSE            reduce using rule 20 (expr -> dispatch .)
    FI              reduce using rule 20 (expr -> dispatch .)
    IN              reduce using rule 20 (expr -> dispatch .)


state 42

    (40) while_expr -> WHILE . expr LOOP expr POOL
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 81
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 43

    (28) expr -> un_op .

    .               reduce using rule 28 (expr -> un_op .)
    @               reduce using rule 28 (expr -> un_op .)
    +               reduce using rule 28 (expr -> un_op .)
    -               reduce using rule 28 (expr -> un_op .)
    *               reduce using rule 28 (expr -> un_op .)
    /               reduce using rule 28 (expr -> un_op .)
    <               reduce using rule 28 (expr -> un_op .)
    LE              reduce using rule 28 (expr -> un_op .)
    =               reduce using rule 28 (expr -> un_op .)
    ;               reduce using rule 28 (expr -> un_op .)
    LOOP            reduce using rule 28 (expr -> un_op .)
    OF              reduce using rule 28 (expr -> un_op .)
    )               reduce using rule 28 (expr -> un_op .)
    THEN            reduce using rule 28 (expr -> un_op .)
    ,               reduce using rule 28 (expr -> un_op .)
    }               reduce using rule 28 (expr -> un_op .)
    POOL            reduce using rule 28 (expr -> un_op .)
    ELSE            reduce using rule 28 (expr -> un_op .)
    FI              reduce using rule 28 (expr -> un_op .)
    IN              reduce using rule 28 (expr -> un_op .)


state 44

    (83) bool -> BOOL_CONST .

    )               reduce using rule 83 (bool -> BOOL_CONST .)
    .               reduce using rule 83 (bool -> BOOL_CONST .)
    @               reduce using rule 83 (bool -> BOOL_CONST .)
    +               reduce using rule 83 (bool -> BOOL_CONST .)
    -               reduce using rule 83 (bool -> BOOL_CONST .)
    *               reduce using rule 83 (bool -> BOOL_CONST .)
    /               reduce using rule 83 (bool -> BOOL_CONST .)
    <               reduce using rule 83 (bool -> BOOL_CONST .)
    LE              reduce using rule 83 (bool -> BOOL_CONST .)
    =               reduce using rule 83 (bool -> BOOL_CONST .)
    ,               reduce using rule 83 (bool -> BOOL_CONST .)
    ;               reduce using rule 83 (bool -> BOOL_CONST .)
    LOOP            reduce using rule 83 (bool -> BOOL_CONST .)
    OF              reduce using rule 83 (bool -> BOOL_CONST .)
    THEN            reduce using rule 83 (bool -> BOOL_CONST .)
    }               reduce using rule 83 (bool -> BOOL_CONST .)
    POOL            reduce using rule 83 (bool -> BOOL_CONST .)
    ELSE            reduce using rule 83 (bool -> BOOL_CONST .)
    FI              reduce using rule 83 (bool -> BOOL_CONST .)
    IN              reduce using rule 83 (bool -> BOOL_CONST .)


state 45

    (73) new -> NEW . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 82
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 46

    (60) bin_op -> eq .

    .               reduce using rule 60 (bin_op -> eq .)
    @               reduce using rule 60 (bin_op -> eq .)
    +               reduce using rule 60 (bin_op -> eq .)
    -               reduce using rule 60 (bin_op -> eq .)
    *               reduce using rule 60 (bin_op -> eq .)
    /               reduce using rule 60 (bin_op -> eq .)
    <               reduce using rule 60 (bin_op -> eq .)
    LE              reduce using rule 60 (bin_op -> eq .)
    =               reduce using rule 60 (bin_op -> eq .)
    ;               reduce using rule 60 (bin_op -> eq .)
    LOOP            reduce using rule 60 (bin_op -> eq .)
    OF              reduce using rule 60 (bin_op -> eq .)
    )               reduce using rule 60 (bin_op -> eq .)
    THEN            reduce using rule 60 (bin_op -> eq .)
    ,               reduce using rule 60 (bin_op -> eq .)
    }               reduce using rule 60 (bin_op -> eq .)
    POOL            reduce using rule 60 (bin_op -> eq .)
    ELSE            reduce using rule 60 (bin_op -> eq .)
    FI              reduce using rule 60 (bin_op -> eq .)
    IN              reduce using rule 60 (bin_op -> eq .)


state 47

    (45) case_expr -> CASE . expr OF case_list ESAC
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 83
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 48

    (74) isvoid -> ISVOID . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 84
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 49

    (82) int -> INT_CONST .

    POOL            reduce using rule 82 (int -> INT_CONST .)
    .               reduce using rule 82 (int -> INT_CONST .)
    @               reduce using rule 82 (int -> INT_CONST .)
    +               reduce using rule 82 (int -> INT_CONST .)
    -               reduce using rule 82 (int -> INT_CONST .)
    *               reduce using rule 82 (int -> INT_CONST .)
    /               reduce using rule 82 (int -> INT_CONST .)
    <               reduce using rule 82 (int -> INT_CONST .)
    LE              reduce using rule 82 (int -> INT_CONST .)
    =               reduce using rule 82 (int -> INT_CONST .)
    ,               reduce using rule 82 (int -> INT_CONST .)
    IN              reduce using rule 82 (int -> INT_CONST .)
    ;               reduce using rule 82 (int -> INT_CONST .)
    LOOP            reduce using rule 82 (int -> INT_CONST .)
    OF              reduce using rule 82 (int -> INT_CONST .)
    )               reduce using rule 82 (int -> INT_CONST .)
    THEN            reduce using rule 82 (int -> INT_CONST .)
    }               reduce using rule 82 (int -> INT_CONST .)
    ELSE            reduce using rule 82 (int -> INT_CONST .)
    FI              reduce using rule 82 (int -> INT_CONST .)


state 50

    (59) bin_op -> le .

    .               reduce using rule 59 (bin_op -> le .)
    @               reduce using rule 59 (bin_op -> le .)
    +               reduce using rule 59 (bin_op -> le .)
    -               reduce using rule 59 (bin_op -> le .)
    *               reduce using rule 59 (bin_op -> le .)
    /               reduce using rule 59 (bin_op -> le .)
    <               reduce using rule 59 (bin_op -> le .)
    LE              reduce using rule 59 (bin_op -> le .)
    =               reduce using rule 59 (bin_op -> le .)
    ;               reduce using rule 59 (bin_op -> le .)
    LOOP            reduce using rule 59 (bin_op -> le .)
    OF              reduce using rule 59 (bin_op -> le .)
    )               reduce using rule 59 (bin_op -> le .)
    THEN            reduce using rule 59 (bin_op -> le .)
    ,               reduce using rule 59 (bin_op -> le .)
    }               reduce using rule 59 (bin_op -> le .)
    POOL            reduce using rule 59 (bin_op -> le .)
    ELSE            reduce using rule 59 (bin_op -> le .)
    FI              reduce using rule 59 (bin_op -> le .)
    IN              reduce using rule 59 (bin_op -> le .)


state 51

    (55) bin_op -> sub .

    .               reduce using rule 55 (bin_op -> sub .)
    @               reduce using rule 55 (bin_op -> sub .)
    +               reduce using rule 55 (bin_op -> sub .)
    -               reduce using rule 55 (bin_op -> sub .)
    *               reduce using rule 55 (bin_op -> sub .)
    /               reduce using rule 55 (bin_op -> sub .)
    <               reduce using rule 55 (bin_op -> sub .)
    LE              reduce using rule 55 (bin_op -> sub .)
    =               reduce using rule 55 (bin_op -> sub .)
    ;               reduce using rule 55 (bin_op -> sub .)
    LOOP            reduce using rule 55 (bin_op -> sub .)
    OF              reduce using rule 55 (bin_op -> sub .)
    )               reduce using rule 55 (bin_op -> sub .)
    THEN            reduce using rule 55 (bin_op -> sub .)
    ,               reduce using rule 55 (bin_op -> sub .)
    }               reduce using rule 55 (bin_op -> sub .)
    POOL            reduce using rule 55 (bin_op -> sub .)
    ELSE            reduce using rule 55 (bin_op -> sub .)
    FI              reduce using rule 55 (bin_op -> sub .)
    IN              reduce using rule 55 (bin_op -> sub .)


state 52

    (42) parens -> ( . expr )
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 85
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 53

    (70) un_op -> isvoid .

    FI              reduce using rule 70 (un_op -> isvoid .)
    .               reduce using rule 70 (un_op -> isvoid .)
    @               reduce using rule 70 (un_op -> isvoid .)
    +               reduce using rule 70 (un_op -> isvoid .)
    -               reduce using rule 70 (un_op -> isvoid .)
    *               reduce using rule 70 (un_op -> isvoid .)
    /               reduce using rule 70 (un_op -> isvoid .)
    <               reduce using rule 70 (un_op -> isvoid .)
    LE              reduce using rule 70 (un_op -> isvoid .)
    =               reduce using rule 70 (un_op -> isvoid .)
    ;               reduce using rule 70 (un_op -> isvoid .)
    LOOP            reduce using rule 70 (un_op -> isvoid .)
    OF              reduce using rule 70 (un_op -> isvoid .)
    )               reduce using rule 70 (un_op -> isvoid .)
    THEN            reduce using rule 70 (un_op -> isvoid .)
    ,               reduce using rule 70 (un_op -> isvoid .)
    }               reduce using rule 70 (un_op -> isvoid .)
    POOL            reduce using rule 70 (un_op -> isvoid .)
    ELSE            reduce using rule 70 (un_op -> isvoid .)
    IN              reduce using rule 70 (un_op -> isvoid .)


state 54

    (58) bin_op -> lt .

    .               reduce using rule 58 (bin_op -> lt .)
    @               reduce using rule 58 (bin_op -> lt .)
    +               reduce using rule 58 (bin_op -> lt .)
    -               reduce using rule 58 (bin_op -> lt .)
    *               reduce using rule 58 (bin_op -> lt .)
    /               reduce using rule 58 (bin_op -> lt .)
    <               reduce using rule 58 (bin_op -> lt .)
    LE              reduce using rule 58 (bin_op -> lt .)
    =               reduce using rule 58 (bin_op -> lt .)
    ;               reduce using rule 58 (bin_op -> lt .)
    LOOP            reduce using rule 58 (bin_op -> lt .)
    OF              reduce using rule 58 (bin_op -> lt .)
    )               reduce using rule 58 (bin_op -> lt .)
    THEN            reduce using rule 58 (bin_op -> lt .)
    ,               reduce using rule 58 (bin_op -> lt .)
    }               reduce using rule 58 (bin_op -> lt .)
    POOL            reduce using rule 58 (bin_op -> lt .)
    ELSE            reduce using rule 58 (bin_op -> lt .)
    FI              reduce using rule 58 (bin_op -> lt .)
    IN              reduce using rule 58 (bin_op -> lt .)


state 55

    (79) ref -> bool .

    .               reduce using rule 79 (ref -> bool .)
    @               reduce using rule 79 (ref -> bool .)
    +               reduce using rule 79 (ref -> bool .)
    -               reduce using rule 79 (ref -> bool .)
    *               reduce using rule 79 (ref -> bool .)
    /               reduce using rule 79 (ref -> bool .)
    <               reduce using rule 79 (ref -> bool .)
    LE              reduce using rule 79 (ref -> bool .)
    =               reduce using rule 79 (ref -> bool .)
    ;               reduce using rule 79 (ref -> bool .)
    LOOP            reduce using rule 79 (ref -> bool .)
    OF              reduce using rule 79 (ref -> bool .)
    )               reduce using rule 79 (ref -> bool .)
    THEN            reduce using rule 79 (ref -> bool .)
    ,               reduce using rule 79 (ref -> bool .)
    }               reduce using rule 79 (ref -> bool .)
    POOL            reduce using rule 79 (ref -> bool .)
    ELSE            reduce using rule 79 (ref -> bool .)
    FI              reduce using rule 79 (ref -> bool .)
    IN              reduce using rule 79 (ref -> bool .)


state 56

    (71) un_op -> comp .

    FI              reduce using rule 71 (un_op -> comp .)
    .               reduce using rule 71 (un_op -> comp .)
    @               reduce using rule 71 (un_op -> comp .)
    +               reduce using rule 71 (un_op -> comp .)
    -               reduce using rule 71 (un_op -> comp .)
    *               reduce using rule 71 (un_op -> comp .)
    /               reduce using rule 71 (un_op -> comp .)
    <               reduce using rule 71 (un_op -> comp .)
    LE              reduce using rule 71 (un_op -> comp .)
    =               reduce using rule 71 (un_op -> comp .)
    ;               reduce using rule 71 (un_op -> comp .)
    LOOP            reduce using rule 71 (un_op -> comp .)
    OF              reduce using rule 71 (un_op -> comp .)
    )               reduce using rule 71 (un_op -> comp .)
    THEN            reduce using rule 71 (un_op -> comp .)
    ,               reduce using rule 71 (un_op -> comp .)
    }               reduce using rule 71 (un_op -> comp .)
    POOL            reduce using rule 71 (un_op -> comp .)
    ELSE            reduce using rule 71 (un_op -> comp .)
    IN              reduce using rule 71 (un_op -> comp .)


state 57

    (54) bin_op -> plus .

    .               reduce using rule 54 (bin_op -> plus .)
    @               reduce using rule 54 (bin_op -> plus .)
    +               reduce using rule 54 (bin_op -> plus .)
    -               reduce using rule 54 (bin_op -> plus .)
    *               reduce using rule 54 (bin_op -> plus .)
    /               reduce using rule 54 (bin_op -> plus .)
    <               reduce using rule 54 (bin_op -> plus .)
    LE              reduce using rule 54 (bin_op -> plus .)
    =               reduce using rule 54 (bin_op -> plus .)
    ;               reduce using rule 54 (bin_op -> plus .)
    LOOP            reduce using rule 54 (bin_op -> plus .)
    OF              reduce using rule 54 (bin_op -> plus .)
    )               reduce using rule 54 (bin_op -> plus .)
    THEN            reduce using rule 54 (bin_op -> plus .)
    ,               reduce using rule 54 (bin_op -> plus .)
    }               reduce using rule 54 (bin_op -> plus .)
    POOL            reduce using rule 54 (bin_op -> plus .)
    ELSE            reduce using rule 54 (bin_op -> plus .)
    FI              reduce using rule 54 (bin_op -> plus .)
    IN              reduce using rule 54 (bin_op -> plus .)


state 58

    (30) expr -> ref .

    .               reduce using rule 30 (expr -> ref .)
    @               reduce using rule 30 (expr -> ref .)
    +               reduce using rule 30 (expr -> ref .)
    -               reduce using rule 30 (expr -> ref .)
    *               reduce using rule 30 (expr -> ref .)
    /               reduce using rule 30 (expr -> ref .)
    <               reduce using rule 30 (expr -> ref .)
    LE              reduce using rule 30 (expr -> ref .)
    =               reduce using rule 30 (expr -> ref .)
    ;               reduce using rule 30 (expr -> ref .)
    LOOP            reduce using rule 30 (expr -> ref .)
    OF              reduce using rule 30 (expr -> ref .)
    )               reduce using rule 30 (expr -> ref .)
    THEN            reduce using rule 30 (expr -> ref .)
    ,               reduce using rule 30 (expr -> ref .)
    }               reduce using rule 30 (expr -> ref .)
    POOL            reduce using rule 30 (expr -> ref .)
    ELSE            reduce using rule 30 (expr -> ref .)
    FI              reduce using rule 30 (expr -> ref .)
    IN              reduce using rule 30 (expr -> ref .)


state 59

    (29) expr -> parens .

    .               reduce using rule 29 (expr -> parens .)
    @               reduce using rule 29 (expr -> parens .)
    +               reduce using rule 29 (expr -> parens .)
    -               reduce using rule 29 (expr -> parens .)
    *               reduce using rule 29 (expr -> parens .)
    /               reduce using rule 29 (expr -> parens .)
    <               reduce using rule 29 (expr -> parens .)
    LE              reduce using rule 29 (expr -> parens .)
    =               reduce using rule 29 (expr -> parens .)
    ;               reduce using rule 29 (expr -> parens .)
    LOOP            reduce using rule 29 (expr -> parens .)
    OF              reduce using rule 29 (expr -> parens .)
    )               reduce using rule 29 (expr -> parens .)
    THEN            reduce using rule 29 (expr -> parens .)
    ,               reduce using rule 29 (expr -> parens .)
    }               reduce using rule 29 (expr -> parens .)
    POOL            reduce using rule 29 (expr -> parens .)
    ELSE            reduce using rule 29 (expr -> parens .)
    FI              reduce using rule 29 (expr -> parens .)
    IN              reduce using rule 29 (expr -> parens .)


state 60

    (78) ref -> string .

    .               reduce using rule 78 (ref -> string .)
    @               reduce using rule 78 (ref -> string .)
    +               reduce using rule 78 (ref -> string .)
    -               reduce using rule 78 (ref -> string .)
    *               reduce using rule 78 (ref -> string .)
    /               reduce using rule 78 (ref -> string .)
    <               reduce using rule 78 (ref -> string .)
    LE              reduce using rule 78 (ref -> string .)
    =               reduce using rule 78 (ref -> string .)
    ;               reduce using rule 78 (ref -> string .)
    LOOP            reduce using rule 78 (ref -> string .)
    OF              reduce using rule 78 (ref -> string .)
    )               reduce using rule 78 (ref -> string .)
    THEN            reduce using rule 78 (ref -> string .)
    ,               reduce using rule 78 (ref -> string .)
    }               reduce using rule 78 (ref -> string .)
    POOL            reduce using rule 78 (ref -> string .)
    ELSE            reduce using rule 78 (ref -> string .)
    FI              reduce using rule 78 (ref -> string .)
    IN              reduce using rule 78 (ref -> string .)


state 61

    (31) assign -> OBJECTID . ASSIGN expr
    (33) dispatch -> OBJECTID . ( actuals )
    (80) object -> OBJECTID .

    ASSIGN          shift and go to state 87
    (               shift and go to state 86
    ELSE            reduce using rule 80 (object -> OBJECTID .)
    FI              reduce using rule 80 (object -> OBJECTID .)
    .               reduce using rule 80 (object -> OBJECTID .)
    @               reduce using rule 80 (object -> OBJECTID .)
    +               reduce using rule 80 (object -> OBJECTID .)
    -               reduce using rule 80 (object -> OBJECTID .)
    *               reduce using rule 80 (object -> OBJECTID .)
    /               reduce using rule 80 (object -> OBJECTID .)
    <               reduce using rule 80 (object -> OBJECTID .)
    LE              reduce using rule 80 (object -> OBJECTID .)
    =               reduce using rule 80 (object -> OBJECTID .)
    ;               reduce using rule 80 (object -> OBJECTID .)
    THEN            reduce using rule 80 (object -> OBJECTID .)
    LOOP            reduce using rule 80 (object -> OBJECTID .)
    OF              reduce using rule 80 (object -> OBJECTID .)
    )               reduce using rule 80 (object -> OBJECTID .)
    ,               reduce using rule 80 (object -> OBJECTID .)
    }               reduce using rule 80 (object -> OBJECTID .)
    POOL            reduce using rule 80 (object -> OBJECTID .)
    IN              reduce using rule 80 (object -> OBJECTID .)


state 62

    (23) expr -> while_expr .

    .               reduce using rule 23 (expr -> while_expr .)
    @               reduce using rule 23 (expr -> while_expr .)
    +               reduce using rule 23 (expr -> while_expr .)
    -               reduce using rule 23 (expr -> while_expr .)
    *               reduce using rule 23 (expr -> while_expr .)
    /               reduce using rule 23 (expr -> while_expr .)
    <               reduce using rule 23 (expr -> while_expr .)
    LE              reduce using rule 23 (expr -> while_expr .)
    =               reduce using rule 23 (expr -> while_expr .)
    ;               reduce using rule 23 (expr -> while_expr .)
    LOOP            reduce using rule 23 (expr -> while_expr .)
    OF              reduce using rule 23 (expr -> while_expr .)
    )               reduce using rule 23 (expr -> while_expr .)
    THEN            reduce using rule 23 (expr -> while_expr .)
    ,               reduce using rule 23 (expr -> while_expr .)
    }               reduce using rule 23 (expr -> while_expr .)
    POOL            reduce using rule 23 (expr -> while_expr .)
    ELSE            reduce using rule 23 (expr -> while_expr .)
    FI              reduce using rule 23 (expr -> while_expr .)
    IN              reduce using rule 23 (expr -> while_expr .)


state 63

    (76) ref -> object .

    .               reduce using rule 76 (ref -> object .)
    @               reduce using rule 76 (ref -> object .)
    +               reduce using rule 76 (ref -> object .)
    -               reduce using rule 76 (ref -> object .)
    *               reduce using rule 76 (ref -> object .)
    /               reduce using rule 76 (ref -> object .)
    <               reduce using rule 76 (ref -> object .)
    LE              reduce using rule 76 (ref -> object .)
    =               reduce using rule 76 (ref -> object .)
    ;               reduce using rule 76 (ref -> object .)
    LOOP            reduce using rule 76 (ref -> object .)
    OF              reduce using rule 76 (ref -> object .)
    )               reduce using rule 76 (ref -> object .)
    THEN            reduce using rule 76 (ref -> object .)
    ,               reduce using rule 76 (ref -> object .)
    }               reduce using rule 76 (ref -> object .)
    POOL            reduce using rule 76 (ref -> object .)
    ELSE            reduce using rule 76 (ref -> object .)
    FI              reduce using rule 76 (ref -> object .)
    IN              reduce using rule 76 (ref -> object .)


state 64

    (69) un_op -> new .

    FI              reduce using rule 69 (un_op -> new .)
    .               reduce using rule 69 (un_op -> new .)
    @               reduce using rule 69 (un_op -> new .)
    +               reduce using rule 69 (un_op -> new .)
    -               reduce using rule 69 (un_op -> new .)
    *               reduce using rule 69 (un_op -> new .)
    /               reduce using rule 69 (un_op -> new .)
    <               reduce using rule 69 (un_op -> new .)
    LE              reduce using rule 69 (un_op -> new .)
    =               reduce using rule 69 (un_op -> new .)
    ;               reduce using rule 69 (un_op -> new .)
    LOOP            reduce using rule 69 (un_op -> new .)
    OF              reduce using rule 69 (un_op -> new .)
    )               reduce using rule 69 (un_op -> new .)
    THEN            reduce using rule 69 (un_op -> new .)
    ,               reduce using rule 69 (un_op -> new .)
    }               reduce using rule 69 (un_op -> new .)
    POOL            reduce using rule 69 (un_op -> new .)
    ELSE            reduce using rule 69 (un_op -> new .)
    IN              reduce using rule 69 (un_op -> new .)


state 65

    (75) comp -> NOT . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 88
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 66

    (56) bin_op -> mul .

    .               reduce using rule 56 (bin_op -> mul .)
    @               reduce using rule 56 (bin_op -> mul .)
    +               reduce using rule 56 (bin_op -> mul .)
    -               reduce using rule 56 (bin_op -> mul .)
    *               reduce using rule 56 (bin_op -> mul .)
    /               reduce using rule 56 (bin_op -> mul .)
    <               reduce using rule 56 (bin_op -> mul .)
    LE              reduce using rule 56 (bin_op -> mul .)
    =               reduce using rule 56 (bin_op -> mul .)
    ;               reduce using rule 56 (bin_op -> mul .)
    LOOP            reduce using rule 56 (bin_op -> mul .)
    OF              reduce using rule 56 (bin_op -> mul .)
    )               reduce using rule 56 (bin_op -> mul .)
    THEN            reduce using rule 56 (bin_op -> mul .)
    ,               reduce using rule 56 (bin_op -> mul .)
    }               reduce using rule 56 (bin_op -> mul .)
    POOL            reduce using rule 56 (bin_op -> mul .)
    ELSE            reduce using rule 56 (bin_op -> mul .)
    FI              reduce using rule 56 (bin_op -> mul .)
    IN              reduce using rule 56 (bin_op -> mul .)


state 67

    (57) bin_op -> div .

    .               reduce using rule 57 (bin_op -> div .)
    @               reduce using rule 57 (bin_op -> div .)
    +               reduce using rule 57 (bin_op -> div .)
    -               reduce using rule 57 (bin_op -> div .)
    *               reduce using rule 57 (bin_op -> div .)
    /               reduce using rule 57 (bin_op -> div .)
    <               reduce using rule 57 (bin_op -> div .)
    LE              reduce using rule 57 (bin_op -> div .)
    =               reduce using rule 57 (bin_op -> div .)
    ;               reduce using rule 57 (bin_op -> div .)
    LOOP            reduce using rule 57 (bin_op -> div .)
    OF              reduce using rule 57 (bin_op -> div .)
    )               reduce using rule 57 (bin_op -> div .)
    THEN            reduce using rule 57 (bin_op -> div .)
    ,               reduce using rule 57 (bin_op -> div .)
    }               reduce using rule 57 (bin_op -> div .)
    POOL            reduce using rule 57 (bin_op -> div .)
    ELSE            reduce using rule 57 (bin_op -> div .)
    FI              reduce using rule 57 (bin_op -> div .)
    IN              reduce using rule 57 (bin_op -> div .)


state 68

    (38) if_expr -> IF . expr THEN expr ELSE expr FI
    (39) if_expr -> IF . expr THEN expr FI
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 89
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 69

    (22) expr -> if_expr .

    .               reduce using rule 22 (expr -> if_expr .)
    @               reduce using rule 22 (expr -> if_expr .)
    +               reduce using rule 22 (expr -> if_expr .)
    -               reduce using rule 22 (expr -> if_expr .)
    *               reduce using rule 22 (expr -> if_expr .)
    /               reduce using rule 22 (expr -> if_expr .)
    <               reduce using rule 22 (expr -> if_expr .)
    LE              reduce using rule 22 (expr -> if_expr .)
    =               reduce using rule 22 (expr -> if_expr .)
    ;               reduce using rule 22 (expr -> if_expr .)
    LOOP            reduce using rule 22 (expr -> if_expr .)
    OF              reduce using rule 22 (expr -> if_expr .)
    )               reduce using rule 22 (expr -> if_expr .)
    THEN            reduce using rule 22 (expr -> if_expr .)
    ,               reduce using rule 22 (expr -> if_expr .)
    }               reduce using rule 22 (expr -> if_expr .)
    POOL            reduce using rule 22 (expr -> if_expr .)
    ELSE            reduce using rule 22 (expr -> if_expr .)
    FI              reduce using rule 22 (expr -> if_expr .)
    IN              reduce using rule 22 (expr -> if_expr .)


state 70

    (21) expr -> static_dispatch .

    .               reduce using rule 21 (expr -> static_dispatch .)
    @               reduce using rule 21 (expr -> static_dispatch .)
    +               reduce using rule 21 (expr -> static_dispatch .)
    -               reduce using rule 21 (expr -> static_dispatch .)
    *               reduce using rule 21 (expr -> static_dispatch .)
    /               reduce using rule 21 (expr -> static_dispatch .)
    <               reduce using rule 21 (expr -> static_dispatch .)
    LE              reduce using rule 21 (expr -> static_dispatch .)
    =               reduce using rule 21 (expr -> static_dispatch .)
    ;               reduce using rule 21 (expr -> static_dispatch .)
    LOOP            reduce using rule 21 (expr -> static_dispatch .)
    OF              reduce using rule 21 (expr -> static_dispatch .)
    )               reduce using rule 21 (expr -> static_dispatch .)
    THEN            reduce using rule 21 (expr -> static_dispatch .)
    ,               reduce using rule 21 (expr -> static_dispatch .)
    }               reduce using rule 21 (expr -> static_dispatch .)
    POOL            reduce using rule 21 (expr -> static_dispatch .)
    ELSE            reduce using rule 21 (expr -> static_dispatch .)
    FI              reduce using rule 21 (expr -> static_dispatch .)
    IN              reduce using rule 21 (expr -> static_dispatch .)


state 71

    (13) attr -> OBJECTID : TYPEID ASSIGN expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    ;               reduce using rule 13 (attr -> OBJECTID : TYPEID ASSIGN expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 72

    (68) un_op -> neg .

    FI              reduce using rule 68 (un_op -> neg .)
    .               reduce using rule 68 (un_op -> neg .)
    @               reduce using rule 68 (un_op -> neg .)
    +               reduce using rule 68 (un_op -> neg .)
    -               reduce using rule 68 (un_op -> neg .)
    *               reduce using rule 68 (un_op -> neg .)
    /               reduce using rule 68 (un_op -> neg .)
    <               reduce using rule 68 (un_op -> neg .)
    LE              reduce using rule 68 (un_op -> neg .)
    =               reduce using rule 68 (un_op -> neg .)
    ;               reduce using rule 68 (un_op -> neg .)
    LOOP            reduce using rule 68 (un_op -> neg .)
    OF              reduce using rule 68 (un_op -> neg .)
    )               reduce using rule 68 (un_op -> neg .)
    THEN            reduce using rule 68 (un_op -> neg .)
    ,               reduce using rule 68 (un_op -> neg .)
    }               reduce using rule 68 (un_op -> neg .)
    POOL            reduce using rule 68 (un_op -> neg .)
    ELSE            reduce using rule 68 (un_op -> neg .)
    IN              reduce using rule 68 (un_op -> neg .)


state 73

    (27) expr -> bin_op .

    .               reduce using rule 27 (expr -> bin_op .)
    @               reduce using rule 27 (expr -> bin_op .)
    +               reduce using rule 27 (expr -> bin_op .)
    -               reduce using rule 27 (expr -> bin_op .)
    *               reduce using rule 27 (expr -> bin_op .)
    /               reduce using rule 27 (expr -> bin_op .)
    <               reduce using rule 27 (expr -> bin_op .)
    LE              reduce using rule 27 (expr -> bin_op .)
    =               reduce using rule 27 (expr -> bin_op .)
    ;               reduce using rule 27 (expr -> bin_op .)
    LOOP            reduce using rule 27 (expr -> bin_op .)
    OF              reduce using rule 27 (expr -> bin_op .)
    )               reduce using rule 27 (expr -> bin_op .)
    THEN            reduce using rule 27 (expr -> bin_op .)
    ,               reduce using rule 27 (expr -> bin_op .)
    }               reduce using rule 27 (expr -> bin_op .)
    POOL            reduce using rule 27 (expr -> bin_op .)
    ELSE            reduce using rule 27 (expr -> bin_op .)
    FI              reduce using rule 27 (expr -> bin_op .)
    IN              reduce using rule 27 (expr -> bin_op .)


state 74

    (25) expr -> LET . let_list IN expr
    (48) let_list -> . OBJECTID : TYPEID more_let
    (49) let_list -> . OBJECTID : TYPEID ASSIGN expr more_let

    OBJECTID        shift and go to state 100

    let_list                       shift and go to state 99

state 75

    (41) block -> { . expr_list }
    (43) expr_list -> . expr ; expr_list
    (44) expr_list -> . empty
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (84) empty -> .
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    }               reduce using rule 84 (empty -> .)
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    expr_list                      shift and go to state 101
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    empty                          shift and go to state 102
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    dispatch                       shift and go to state 41
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 103
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 76

    (19) expr -> assign .

    .               reduce using rule 19 (expr -> assign .)
    @               reduce using rule 19 (expr -> assign .)
    +               reduce using rule 19 (expr -> assign .)
    -               reduce using rule 19 (expr -> assign .)
    *               reduce using rule 19 (expr -> assign .)
    /               reduce using rule 19 (expr -> assign .)
    <               reduce using rule 19 (expr -> assign .)
    LE              reduce using rule 19 (expr -> assign .)
    =               reduce using rule 19 (expr -> assign .)
    ;               reduce using rule 19 (expr -> assign .)
    LOOP            reduce using rule 19 (expr -> assign .)
    OF              reduce using rule 19 (expr -> assign .)
    )               reduce using rule 19 (expr -> assign .)
    THEN            reduce using rule 19 (expr -> assign .)
    ,               reduce using rule 19 (expr -> assign .)
    }               reduce using rule 19 (expr -> assign .)
    POOL            reduce using rule 19 (expr -> assign .)
    ELSE            reduce using rule 19 (expr -> assign .)
    FI              reduce using rule 19 (expr -> assign .)
    IN              reduce using rule 19 (expr -> assign .)


state 77

    (24) expr -> block .

    .               reduce using rule 24 (expr -> block .)
    @               reduce using rule 24 (expr -> block .)
    +               reduce using rule 24 (expr -> block .)
    -               reduce using rule 24 (expr -> block .)
    *               reduce using rule 24 (expr -> block .)
    /               reduce using rule 24 (expr -> block .)
    <               reduce using rule 24 (expr -> block .)
    LE              reduce using rule 24 (expr -> block .)
    =               reduce using rule 24 (expr -> block .)
    ;               reduce using rule 24 (expr -> block .)
    LOOP            reduce using rule 24 (expr -> block .)
    OF              reduce using rule 24 (expr -> block .)
    )               reduce using rule 24 (expr -> block .)
    THEN            reduce using rule 24 (expr -> block .)
    ,               reduce using rule 24 (expr -> block .)
    }               reduce using rule 24 (expr -> block .)
    POOL            reduce using rule 24 (expr -> block .)
    ELSE            reduce using rule 24 (expr -> block .)
    FI              reduce using rule 24 (expr -> block .)
    IN              reduce using rule 24 (expr -> block .)


state 78

    (72) neg -> ~ . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 104
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 79

    (17) more_formals -> , formal more_formals .

    )               reduce using rule 17 (more_formals -> , formal more_formals .)


state 80

    (11) method -> OBJECTID ( formals ) : TYPEID . { expr }

    {               shift and go to state 105


state 81

    (40) while_expr -> WHILE expr . LOOP expr POOL
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    LOOP            shift and go to state 106
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 82

    (73) new -> NEW expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 73 (new -> NEW expr .)
    LOOP            reduce using rule 73 (new -> NEW expr .)
    OF              reduce using rule 73 (new -> NEW expr .)
    )               reduce using rule 73 (new -> NEW expr .)
    THEN            reduce using rule 73 (new -> NEW expr .)
    ,               reduce using rule 73 (new -> NEW expr .)
    }               reduce using rule 73 (new -> NEW expr .)
    POOL            reduce using rule 73 (new -> NEW expr .)
    ELSE            reduce using rule 73 (new -> NEW expr .)
    FI              reduce using rule 73 (new -> NEW expr .)
    IN              reduce using rule 73 (new -> NEW expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 73 (new -> NEW expr .) ]
  ! @               [ reduce using rule 73 (new -> NEW expr .) ]
  ! +               [ reduce using rule 73 (new -> NEW expr .) ]
  ! -               [ reduce using rule 73 (new -> NEW expr .) ]
  ! *               [ reduce using rule 73 (new -> NEW expr .) ]
  ! /               [ reduce using rule 73 (new -> NEW expr .) ]
  ! <               [ reduce using rule 73 (new -> NEW expr .) ]
  ! LE              [ reduce using rule 73 (new -> NEW expr .) ]
  ! =               [ reduce using rule 73 (new -> NEW expr .) ]


state 83

    (45) case_expr -> CASE expr . OF case_list ESAC
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    OF              shift and go to state 107
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 84

    (74) isvoid -> ISVOID expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ELSE            reduce using rule 74 (isvoid -> ISVOID expr .)
    FI              reduce using rule 74 (isvoid -> ISVOID expr .)
    ;               reduce using rule 74 (isvoid -> ISVOID expr .)
    LOOP            reduce using rule 74 (isvoid -> ISVOID expr .)
    OF              reduce using rule 74 (isvoid -> ISVOID expr .)
    )               reduce using rule 74 (isvoid -> ISVOID expr .)
    THEN            reduce using rule 74 (isvoid -> ISVOID expr .)
    ,               reduce using rule 74 (isvoid -> ISVOID expr .)
    }               reduce using rule 74 (isvoid -> ISVOID expr .)
    POOL            reduce using rule 74 (isvoid -> ISVOID expr .)
    IN              reduce using rule 74 (isvoid -> ISVOID expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! @               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! +               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! -               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! *               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! /               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! <               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! LE              [ reduce using rule 74 (isvoid -> ISVOID expr .) ]
  ! =               [ reduce using rule 74 (isvoid -> ISVOID expr .) ]


state 85

    (42) parens -> ( expr . )
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    )               shift and go to state 108
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 86

    (33) dispatch -> OBJECTID ( . actuals )
    (35) actuals -> . expr more_actuals
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    actuals                        shift and go to state 109
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 110
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 87

    (31) assign -> OBJECTID ASSIGN . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 111
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 88

    (75) comp -> NOT expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ,               reduce using rule 75 (comp -> NOT expr .)
    )               reduce using rule 75 (comp -> NOT expr .)
    IN              reduce using rule 75 (comp -> NOT expr .)
    ;               reduce using rule 75 (comp -> NOT expr .)
    LOOP            reduce using rule 75 (comp -> NOT expr .)
    OF              reduce using rule 75 (comp -> NOT expr .)
    THEN            reduce using rule 75 (comp -> NOT expr .)
    }               reduce using rule 75 (comp -> NOT expr .)
    POOL            reduce using rule 75 (comp -> NOT expr .)
    ELSE            reduce using rule 75 (comp -> NOT expr .)
    FI              reduce using rule 75 (comp -> NOT expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! @               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! +               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! -               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! *               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! /               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! <               [ reduce using rule 75 (comp -> NOT expr .) ]
  ! LE              [ reduce using rule 75 (comp -> NOT expr .) ]
  ! =               [ reduce using rule 75 (comp -> NOT expr .) ]


state 89

    (38) if_expr -> IF expr . THEN expr ELSE expr FI
    (39) if_expr -> IF expr . THEN expr FI
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    THEN            shift and go to state 112
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 90

    (66) le -> expr LE . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 113
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 91

    (34) static_dispatch -> expr @ . TYPEID . OBJECTID ( actuals )

    TYPEID          shift and go to state 114


state 92

    (61) plus -> expr + . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 115
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 93

    (63) mul -> expr * . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 116
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 94

    (62) sub -> expr - . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 117
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 95

    (64) div -> expr / . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 118
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 96

    (32) dispatch -> expr . . OBJECTID ( actuals )

    OBJECTID        shift and go to state 119


state 97

    (65) lt -> expr < . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 120
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 98

    (67) eq -> expr = . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 121
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 99

    (25) expr -> LET let_list . IN expr

    IN              shift and go to state 122


state 100

    (48) let_list -> OBJECTID . : TYPEID more_let
    (49) let_list -> OBJECTID . : TYPEID ASSIGN expr more_let

    :               shift and go to state 123


state 101

    (41) block -> { expr_list . }

    }               shift and go to state 124


state 102

    (44) expr_list -> empty .

    }               reduce using rule 44 (expr_list -> empty .)


state 103

    (43) expr_list -> expr . ; expr_list
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    ;               shift and go to state 125
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 104

    (72) neg -> ~ expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    LOOP            reduce using rule 72 (neg -> ~ expr .)
    ,               reduce using rule 72 (neg -> ~ expr .)
    IN              reduce using rule 72 (neg -> ~ expr .)
    ;               reduce using rule 72 (neg -> ~ expr .)
    )               reduce using rule 72 (neg -> ~ expr .)
    ELSE            reduce using rule 72 (neg -> ~ expr .)
    FI              reduce using rule 72 (neg -> ~ expr .)
    OF              reduce using rule 72 (neg -> ~ expr .)
    THEN            reduce using rule 72 (neg -> ~ expr .)
    }               reduce using rule 72 (neg -> ~ expr .)
    POOL            reduce using rule 72 (neg -> ~ expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! @               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! +               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! -               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! *               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! /               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! <               [ reduce using rule 72 (neg -> ~ expr .) ]
  ! LE              [ reduce using rule 72 (neg -> ~ expr .) ]
  ! =               [ reduce using rule 72 (neg -> ~ expr .) ]


state 105

    (11) method -> OBJECTID ( formals ) : TYPEID { . expr }
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 126
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 106

    (40) while_expr -> WHILE expr LOOP . expr POOL
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 127
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 107

    (45) case_expr -> CASE expr OF . case_list ESAC
    (46) case_list -> . case case_list
    (47) case_list -> . empty
    (53) case -> . OBJECTID : TYPEID DARROW expr ;
    (84) empty -> .

    OBJECTID        shift and go to state 129
    ESAC            reduce using rule 84 (empty -> .)

    case                           shift and go to state 128
    empty                          shift and go to state 131
    case_list                      shift and go to state 130

state 108

    (42) parens -> ( expr ) .

    .               reduce using rule 42 (parens -> ( expr ) .)
    @               reduce using rule 42 (parens -> ( expr ) .)
    +               reduce using rule 42 (parens -> ( expr ) .)
    -               reduce using rule 42 (parens -> ( expr ) .)
    *               reduce using rule 42 (parens -> ( expr ) .)
    /               reduce using rule 42 (parens -> ( expr ) .)
    <               reduce using rule 42 (parens -> ( expr ) .)
    LE              reduce using rule 42 (parens -> ( expr ) .)
    =               reduce using rule 42 (parens -> ( expr ) .)
    ;               reduce using rule 42 (parens -> ( expr ) .)
    LOOP            reduce using rule 42 (parens -> ( expr ) .)
    OF              reduce using rule 42 (parens -> ( expr ) .)
    )               reduce using rule 42 (parens -> ( expr ) .)
    THEN            reduce using rule 42 (parens -> ( expr ) .)
    ,               reduce using rule 42 (parens -> ( expr ) .)
    }               reduce using rule 42 (parens -> ( expr ) .)
    POOL            reduce using rule 42 (parens -> ( expr ) .)
    ELSE            reduce using rule 42 (parens -> ( expr ) .)
    FI              reduce using rule 42 (parens -> ( expr ) .)
    IN              reduce using rule 42 (parens -> ( expr ) .)


state 109

    (33) dispatch -> OBJECTID ( actuals . )

    )               shift and go to state 132


state 110

    (35) actuals -> expr . more_actuals
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr
    (36) more_actuals -> . , expr more_actuals
    (37) more_actuals -> . empty
    (84) empty -> .

    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98
    ,               shift and go to state 134
    )               reduce using rule 84 (empty -> .)

    more_actuals                   shift and go to state 133
    empty                          shift and go to state 135

state 111

    (31) assign -> OBJECTID ASSIGN expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    LOOP            reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    OF              reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    )               reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    THEN            reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    ,               reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    }               reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    POOL            reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    ELSE            reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    FI              reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    IN              reduce using rule 31 (assign -> OBJECTID ASSIGN expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! @               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! +               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! -               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! *               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! /               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! <               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! LE              [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]
  ! =               [ reduce using rule 31 (assign -> OBJECTID ASSIGN expr .) ]


state 112

    (38) if_expr -> IF expr THEN . expr ELSE expr FI
    (39) if_expr -> IF expr THEN . expr FI
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 136
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 113

    (66) le -> expr LE expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    }               reduce using rule 66 (le -> expr LE expr .)
    ;               reduce using rule 66 (le -> expr LE expr .)
    LOOP            reduce using rule 66 (le -> expr LE expr .)
    OF              reduce using rule 66 (le -> expr LE expr .)
    )               reduce using rule 66 (le -> expr LE expr .)
    THEN            reduce using rule 66 (le -> expr LE expr .)
    ,               reduce using rule 66 (le -> expr LE expr .)
    POOL            reduce using rule 66 (le -> expr LE expr .)
    ELSE            reduce using rule 66 (le -> expr LE expr .)
    FI              reduce using rule 66 (le -> expr LE expr .)
    IN              reduce using rule 66 (le -> expr LE expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! @               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! +               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! -               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! *               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! /               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! <               [ reduce using rule 66 (le -> expr LE expr .) ]
  ! LE              [ reduce using rule 66 (le -> expr LE expr .) ]
  ! =               [ reduce using rule 66 (le -> expr LE expr .) ]


state 114

    (34) static_dispatch -> expr @ TYPEID . . OBJECTID ( actuals )

    .               shift and go to state 137


state 115

    (61) plus -> expr + expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 61 (plus -> expr + expr .)
    LOOP            reduce using rule 61 (plus -> expr + expr .)
    OF              reduce using rule 61 (plus -> expr + expr .)
    )               reduce using rule 61 (plus -> expr + expr .)
    THEN            reduce using rule 61 (plus -> expr + expr .)
    ,               reduce using rule 61 (plus -> expr + expr .)
    }               reduce using rule 61 (plus -> expr + expr .)
    POOL            reduce using rule 61 (plus -> expr + expr .)
    ELSE            reduce using rule 61 (plus -> expr + expr .)
    FI              reduce using rule 61 (plus -> expr + expr .)
    IN              reduce using rule 61 (plus -> expr + expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! @               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! +               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! -               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! *               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! /               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! <               [ reduce using rule 61 (plus -> expr + expr .) ]
  ! LE              [ reduce using rule 61 (plus -> expr + expr .) ]
  ! =               [ reduce using rule 61 (plus -> expr + expr .) ]


state 116

    (63) mul -> expr * expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 63 (mul -> expr * expr .)
    LOOP            reduce using rule 63 (mul -> expr * expr .)
    OF              reduce using rule 63 (mul -> expr * expr .)
    )               reduce using rule 63 (mul -> expr * expr .)
    THEN            reduce using rule 63 (mul -> expr * expr .)
    ,               reduce using rule 63 (mul -> expr * expr .)
    }               reduce using rule 63 (mul -> expr * expr .)
    POOL            reduce using rule 63 (mul -> expr * expr .)
    ELSE            reduce using rule 63 (mul -> expr * expr .)
    FI              reduce using rule 63 (mul -> expr * expr .)
    IN              reduce using rule 63 (mul -> expr * expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! @               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! +               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! -               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! *               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! /               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! <               [ reduce using rule 63 (mul -> expr * expr .) ]
  ! LE              [ reduce using rule 63 (mul -> expr * expr .) ]
  ! =               [ reduce using rule 63 (mul -> expr * expr .) ]


state 117

    (62) sub -> expr - expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 62 (sub -> expr - expr .)
    LOOP            reduce using rule 62 (sub -> expr - expr .)
    OF              reduce using rule 62 (sub -> expr - expr .)
    )               reduce using rule 62 (sub -> expr - expr .)
    THEN            reduce using rule 62 (sub -> expr - expr .)
    ,               reduce using rule 62 (sub -> expr - expr .)
    }               reduce using rule 62 (sub -> expr - expr .)
    POOL            reduce using rule 62 (sub -> expr - expr .)
    ELSE            reduce using rule 62 (sub -> expr - expr .)
    FI              reduce using rule 62 (sub -> expr - expr .)
    IN              reduce using rule 62 (sub -> expr - expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! @               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! +               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! -               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! *               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! /               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! <               [ reduce using rule 62 (sub -> expr - expr .) ]
  ! LE              [ reduce using rule 62 (sub -> expr - expr .) ]
  ! =               [ reduce using rule 62 (sub -> expr - expr .) ]


state 118

    (64) div -> expr / expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 64 (div -> expr / expr .)
    LOOP            reduce using rule 64 (div -> expr / expr .)
    OF              reduce using rule 64 (div -> expr / expr .)
    )               reduce using rule 64 (div -> expr / expr .)
    THEN            reduce using rule 64 (div -> expr / expr .)
    ,               reduce using rule 64 (div -> expr / expr .)
    }               reduce using rule 64 (div -> expr / expr .)
    POOL            reduce using rule 64 (div -> expr / expr .)
    ELSE            reduce using rule 64 (div -> expr / expr .)
    FI              reduce using rule 64 (div -> expr / expr .)
    IN              reduce using rule 64 (div -> expr / expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 64 (div -> expr / expr .) ]
  ! @               [ reduce using rule 64 (div -> expr / expr .) ]
  ! +               [ reduce using rule 64 (div -> expr / expr .) ]
  ! -               [ reduce using rule 64 (div -> expr / expr .) ]
  ! *               [ reduce using rule 64 (div -> expr / expr .) ]
  ! /               [ reduce using rule 64 (div -> expr / expr .) ]
  ! <               [ reduce using rule 64 (div -> expr / expr .) ]
  ! LE              [ reduce using rule 64 (div -> expr / expr .) ]
  ! =               [ reduce using rule 64 (div -> expr / expr .) ]


state 119

    (32) dispatch -> expr . OBJECTID . ( actuals )

    (               shift and go to state 138


state 120

    (65) lt -> expr < expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ,               reduce using rule 65 (lt -> expr < expr .)
    IN              reduce using rule 65 (lt -> expr < expr .)
    ;               reduce using rule 65 (lt -> expr < expr .)
    LOOP            reduce using rule 65 (lt -> expr < expr .)
    OF              reduce using rule 65 (lt -> expr < expr .)
    )               reduce using rule 65 (lt -> expr < expr .)
    THEN            reduce using rule 65 (lt -> expr < expr .)
    }               reduce using rule 65 (lt -> expr < expr .)
    POOL            reduce using rule 65 (lt -> expr < expr .)
    ELSE            reduce using rule 65 (lt -> expr < expr .)
    FI              reduce using rule 65 (lt -> expr < expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! @               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! +               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! -               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! *               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! /               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! <               [ reduce using rule 65 (lt -> expr < expr .) ]
  ! LE              [ reduce using rule 65 (lt -> expr < expr .) ]
  ! =               [ reduce using rule 65 (lt -> expr < expr .) ]


state 121

    (67) eq -> expr = expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ,               reduce using rule 67 (eq -> expr = expr .)
    )               reduce using rule 67 (eq -> expr = expr .)
    ;               reduce using rule 67 (eq -> expr = expr .)
    LOOP            reduce using rule 67 (eq -> expr = expr .)
    OF              reduce using rule 67 (eq -> expr = expr .)
    THEN            reduce using rule 67 (eq -> expr = expr .)
    }               reduce using rule 67 (eq -> expr = expr .)
    POOL            reduce using rule 67 (eq -> expr = expr .)
    ELSE            reduce using rule 67 (eq -> expr = expr .)
    FI              reduce using rule 67 (eq -> expr = expr .)
    IN              reduce using rule 67 (eq -> expr = expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! @               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! +               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! -               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! *               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! /               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! <               [ reduce using rule 67 (eq -> expr = expr .) ]
  ! LE              [ reduce using rule 67 (eq -> expr = expr .) ]
  ! =               [ reduce using rule 67 (eq -> expr = expr .) ]


state 122

    (25) expr -> LET let_list IN . expr
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 139
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 123

    (48) let_list -> OBJECTID : . TYPEID more_let
    (49) let_list -> OBJECTID : . TYPEID ASSIGN expr more_let

    TYPEID          shift and go to state 140


state 124

    (41) block -> { expr_list } .

    .               reduce using rule 41 (block -> { expr_list } .)
    @               reduce using rule 41 (block -> { expr_list } .)
    +               reduce using rule 41 (block -> { expr_list } .)
    -               reduce using rule 41 (block -> { expr_list } .)
    *               reduce using rule 41 (block -> { expr_list } .)
    /               reduce using rule 41 (block -> { expr_list } .)
    <               reduce using rule 41 (block -> { expr_list } .)
    LE              reduce using rule 41 (block -> { expr_list } .)
    =               reduce using rule 41 (block -> { expr_list } .)
    ,               reduce using rule 41 (block -> { expr_list } .)
    )               reduce using rule 41 (block -> { expr_list } .)
    ;               reduce using rule 41 (block -> { expr_list } .)
    }               reduce using rule 41 (block -> { expr_list } .)
    LOOP            reduce using rule 41 (block -> { expr_list } .)
    OF              reduce using rule 41 (block -> { expr_list } .)
    THEN            reduce using rule 41 (block -> { expr_list } .)
    POOL            reduce using rule 41 (block -> { expr_list } .)
    ELSE            reduce using rule 41 (block -> { expr_list } .)
    FI              reduce using rule 41 (block -> { expr_list } .)
    IN              reduce using rule 41 (block -> { expr_list } .)


state 125

    (43) expr_list -> expr ; . expr_list
    (43) expr_list -> . expr ; expr_list
    (44) expr_list -> . empty
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (84) empty -> .
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    }               reduce using rule 84 (empty -> .)
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    expr_list                      shift and go to state 141
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    empty                          shift and go to state 102
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    dispatch                       shift and go to state 41
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 103
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 126

    (11) method -> OBJECTID ( formals ) : TYPEID { expr . }
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    }               shift and go to state 142
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 127

    (40) while_expr -> WHILE expr LOOP expr . POOL
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    POOL            shift and go to state 143
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 128

    (46) case_list -> case . case_list
    (46) case_list -> . case case_list
    (47) case_list -> . empty
    (53) case -> . OBJECTID : TYPEID DARROW expr ;
    (84) empty -> .

    OBJECTID        shift and go to state 129
    ESAC            reduce using rule 84 (empty -> .)

    case                           shift and go to state 128
    empty                          shift and go to state 131
    case_list                      shift and go to state 144

state 129

    (53) case -> OBJECTID . : TYPEID DARROW expr ;

    :               shift and go to state 145


state 130

    (45) case_expr -> CASE expr OF case_list . ESAC

    ESAC            shift and go to state 146


state 131

    (47) case_list -> empty .

    ESAC            reduce using rule 47 (case_list -> empty .)


state 132

    (33) dispatch -> OBJECTID ( actuals ) .

    .               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    @               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    +               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    -               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    *               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    /               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    <               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    LE              reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    =               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    ;               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    LOOP            reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    OF              reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    )               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    THEN            reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    ,               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    }               reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    POOL            reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    ELSE            reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    FI              reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)
    IN              reduce using rule 33 (dispatch -> OBJECTID ( actuals ) .)


state 133

    (35) actuals -> expr more_actuals .

    )               reduce using rule 35 (actuals -> expr more_actuals .)


state 134

    (36) more_actuals -> , . expr more_actuals
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 147
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 135

    (37) more_actuals -> empty .

    )               reduce using rule 37 (more_actuals -> empty .)


state 136

    (38) if_expr -> IF expr THEN expr . ELSE expr FI
    (39) if_expr -> IF expr THEN expr . FI
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    ELSE            shift and go to state 149
    FI              shift and go to state 148
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 137

    (34) static_dispatch -> expr @ TYPEID . . OBJECTID ( actuals )

    OBJECTID        shift and go to state 150


state 138

    (32) dispatch -> expr . OBJECTID ( . actuals )
    (35) actuals -> . expr more_actuals
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    actuals                        shift and go to state 151
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 110
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 139

    (25) expr -> LET let_list IN expr .
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

  ! shift/reduce conflict for . resolved as shift
  ! shift/reduce conflict for @ resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for < resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for = resolved as shift
    ;               reduce using rule 25 (expr -> LET let_list IN expr .)
    LOOP            reduce using rule 25 (expr -> LET let_list IN expr .)
    OF              reduce using rule 25 (expr -> LET let_list IN expr .)
    )               reduce using rule 25 (expr -> LET let_list IN expr .)
    THEN            reduce using rule 25 (expr -> LET let_list IN expr .)
    ,               reduce using rule 25 (expr -> LET let_list IN expr .)
    }               reduce using rule 25 (expr -> LET let_list IN expr .)
    POOL            reduce using rule 25 (expr -> LET let_list IN expr .)
    ELSE            reduce using rule 25 (expr -> LET let_list IN expr .)
    FI              reduce using rule 25 (expr -> LET let_list IN expr .)
    IN              reduce using rule 25 (expr -> LET let_list IN expr .)
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98

  ! .               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! @               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! +               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! -               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! *               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! /               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! <               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! LE              [ reduce using rule 25 (expr -> LET let_list IN expr .) ]
  ! =               [ reduce using rule 25 (expr -> LET let_list IN expr .) ]


state 140

    (48) let_list -> OBJECTID : TYPEID . more_let
    (49) let_list -> OBJECTID : TYPEID . ASSIGN expr more_let
    (50) more_let -> . , OBJECTID : TYPEID more_let
    (51) more_let -> . , OBJECTID : TYPEID ASSIGN expr more_let
    (52) more_let -> . empty
    (84) empty -> .

    ASSIGN          shift and go to state 154
    ,               shift and go to state 152
    IN              reduce using rule 84 (empty -> .)

    more_let                       shift and go to state 153
    empty                          shift and go to state 155

state 141

    (43) expr_list -> expr ; expr_list .

    }               reduce using rule 43 (expr_list -> expr ; expr_list .)


state 142

    (11) method -> OBJECTID ( formals ) : TYPEID { expr } .

    ;               reduce using rule 11 (method -> OBJECTID ( formals ) : TYPEID { expr } .)


state 143

    (40) while_expr -> WHILE expr LOOP expr POOL .

    THEN            reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    .               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    @               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    +               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    -               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    *               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    /               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    <               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    LE              reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    =               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    POOL            reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    ;               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    LOOP            reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    OF              reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    )               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    ,               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    }               reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    ELSE            reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    FI              reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)
    IN              reduce using rule 40 (while_expr -> WHILE expr LOOP expr POOL .)


state 144

    (46) case_list -> case case_list .

    ESAC            reduce using rule 46 (case_list -> case case_list .)


state 145

    (53) case -> OBJECTID : . TYPEID DARROW expr ;

    TYPEID          shift and go to state 156


state 146

    (45) case_expr -> CASE expr OF case_list ESAC .

    .               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    @               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    +               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    -               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    *               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    /               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    <               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    LE              reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    =               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    ;               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    LOOP            reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    OF              reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    )               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    THEN            reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    ,               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    }               reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    POOL            reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    ELSE            reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    FI              reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)
    IN              reduce using rule 45 (case_expr -> CASE expr OF case_list ESAC .)


state 147

    (36) more_actuals -> , expr . more_actuals
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr
    (36) more_actuals -> . , expr more_actuals
    (37) more_actuals -> . empty
    (84) empty -> .

    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98
    ,               shift and go to state 134
    )               reduce using rule 84 (empty -> .)

    more_actuals                   shift and go to state 157
    empty                          shift and go to state 135

state 148

    (39) if_expr -> IF expr THEN expr FI .

    .               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    @               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    +               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    -               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    *               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    /               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    <               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    LE              reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    =               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    ;               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    LOOP            reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    OF              reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    )               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    THEN            reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    ,               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    }               reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    POOL            reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    ELSE            reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    FI              reduce using rule 39 (if_expr -> IF expr THEN expr FI .)
    IN              reduce using rule 39 (if_expr -> IF expr THEN expr FI .)


state 149

    (38) if_expr -> IF expr THEN expr ELSE . expr FI
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 158
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 150

    (34) static_dispatch -> expr @ TYPEID . OBJECTID . ( actuals )

    (               shift and go to state 159


state 151

    (32) dispatch -> expr . OBJECTID ( actuals . )

    )               shift and go to state 160


state 152

    (50) more_let -> , . OBJECTID : TYPEID more_let
    (51) more_let -> , . OBJECTID : TYPEID ASSIGN expr more_let

    OBJECTID        shift and go to state 161


state 153

    (48) let_list -> OBJECTID : TYPEID more_let .

    IN              reduce using rule 48 (let_list -> OBJECTID : TYPEID more_let .)


state 154

    (49) let_list -> OBJECTID : TYPEID ASSIGN . expr more_let
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 162
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 155

    (52) more_let -> empty .

    IN              reduce using rule 52 (more_let -> empty .)


state 156

    (53) case -> OBJECTID : TYPEID . DARROW expr ;

    DARROW          shift and go to state 163


state 157

    (36) more_actuals -> , expr more_actuals .

    )               reduce using rule 36 (more_actuals -> , expr more_actuals .)


state 158

    (38) if_expr -> IF expr THEN expr ELSE expr . FI
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    FI              shift and go to state 164
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 159

    (34) static_dispatch -> expr @ TYPEID . OBJECTID ( . actuals )
    (35) actuals -> . expr more_actuals
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    actuals                        shift and go to state 165
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 110
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 160

    (32) dispatch -> expr . OBJECTID ( actuals ) .

    .               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    @               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    +               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    -               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    *               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    /               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    <               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    LE              reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    =               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    ;               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    LOOP            reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    OF              reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    )               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    THEN            reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    ,               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    }               reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    POOL            reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    ELSE            reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    FI              reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)
    IN              reduce using rule 32 (dispatch -> expr . OBJECTID ( actuals ) .)


state 161

    (50) more_let -> , OBJECTID . : TYPEID more_let
    (51) more_let -> , OBJECTID . : TYPEID ASSIGN expr more_let

    :               shift and go to state 166


state 162

    (49) let_list -> OBJECTID : TYPEID ASSIGN expr . more_let
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr
    (50) more_let -> . , OBJECTID : TYPEID more_let
    (51) more_let -> . , OBJECTID : TYPEID ASSIGN expr more_let
    (52) more_let -> . empty
    (84) empty -> .

    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98
    ,               shift and go to state 152
    IN              reduce using rule 84 (empty -> .)

    empty                          shift and go to state 155
    more_let                       shift and go to state 167

state 163

    (53) case -> OBJECTID : TYPEID DARROW . expr ;
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 168
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 164

    (38) if_expr -> IF expr THEN expr ELSE expr FI .

    .               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    @               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    +               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    -               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    *               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    /               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    <               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    LE              reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    =               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    ;               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    LOOP            reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    OF              reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    )               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    THEN            reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    ,               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    }               reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    POOL            reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    ELSE            reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    FI              reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)
    IN              reduce using rule 38 (if_expr -> IF expr THEN expr ELSE expr FI .)


state 165

    (34) static_dispatch -> expr @ TYPEID . OBJECTID ( actuals . )

    )               shift and go to state 169


state 166

    (50) more_let -> , OBJECTID : . TYPEID more_let
    (51) more_let -> , OBJECTID : . TYPEID ASSIGN expr more_let

    TYPEID          shift and go to state 170


state 167

    (49) let_list -> OBJECTID : TYPEID ASSIGN expr more_let .

    IN              reduce using rule 49 (let_list -> OBJECTID : TYPEID ASSIGN expr more_let .)


state 168

    (53) case -> OBJECTID : TYPEID DARROW expr . ;
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr

    ;               shift and go to state 171
    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98


state 169

    (34) static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .

    THEN            reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    .               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    @               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    +               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    -               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    *               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    /               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    <               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    LE              reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    =               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    OF              reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    ;               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    ,               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    )               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    IN              reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    LOOP            reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    }               reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    POOL            reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    ELSE            reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)
    FI              reduce using rule 34 (static_dispatch -> expr @ TYPEID . OBJECTID ( actuals ) .)


state 170

    (50) more_let -> , OBJECTID : TYPEID . more_let
    (51) more_let -> , OBJECTID : TYPEID . ASSIGN expr more_let
    (50) more_let -> . , OBJECTID : TYPEID more_let
    (51) more_let -> . , OBJECTID : TYPEID ASSIGN expr more_let
    (52) more_let -> . empty
    (84) empty -> .

    ASSIGN          shift and go to state 173
    ,               shift and go to state 152
    IN              reduce using rule 84 (empty -> .)

    more_let                       shift and go to state 172
    empty                          shift and go to state 155

state 171

    (53) case -> OBJECTID : TYPEID DARROW expr ; .

    OBJECTID        reduce using rule 53 (case -> OBJECTID : TYPEID DARROW expr ; .)
    ESAC            reduce using rule 53 (case -> OBJECTID : TYPEID DARROW expr ; .)


state 172

    (50) more_let -> , OBJECTID : TYPEID more_let .

    IN              reduce using rule 50 (more_let -> , OBJECTID : TYPEID more_let .)


state 173

    (51) more_let -> , OBJECTID : TYPEID ASSIGN . expr more_let
    (19) expr -> . assign
    (20) expr -> . dispatch
    (21) expr -> . static_dispatch
    (22) expr -> . if_expr
    (23) expr -> . while_expr
    (24) expr -> . block
    (25) expr -> . LET let_list IN expr
    (26) expr -> . case_expr
    (27) expr -> . bin_op
    (28) expr -> . un_op
    (29) expr -> . parens
    (30) expr -> . ref
    (31) assign -> . OBJECTID ASSIGN expr
    (32) dispatch -> . expr . OBJECTID ( actuals )
    (33) dispatch -> . OBJECTID ( actuals )
    (34) static_dispatch -> . expr @ TYPEID . OBJECTID ( actuals )
    (38) if_expr -> . IF expr THEN expr ELSE expr FI
    (39) if_expr -> . IF expr THEN expr FI
    (40) while_expr -> . WHILE expr LOOP expr POOL
    (41) block -> . { expr_list }
    (45) case_expr -> . CASE expr OF case_list ESAC
    (54) bin_op -> . plus
    (55) bin_op -> . sub
    (56) bin_op -> . mul
    (57) bin_op -> . div
    (58) bin_op -> . lt
    (59) bin_op -> . le
    (60) bin_op -> . eq
    (68) un_op -> . neg
    (69) un_op -> . new
    (70) un_op -> . isvoid
    (71) un_op -> . comp
    (42) parens -> . ( expr )
    (76) ref -> . object
    (77) ref -> . int
    (78) ref -> . string
    (79) ref -> . bool
    (61) plus -> . expr + expr
    (62) sub -> . expr - expr
    (63) mul -> . expr * expr
    (64) div -> . expr / expr
    (65) lt -> . expr < expr
    (66) le -> . expr LE expr
    (67) eq -> . expr = expr
    (72) neg -> . ~ expr
    (73) new -> . NEW expr
    (74) isvoid -> . ISVOID expr
    (75) comp -> . NOT expr
    (80) object -> . OBJECTID
    (82) int -> . INT_CONST
    (81) string -> . STR_CONST
    (83) bool -> . BOOL_CONST

    LET             shift and go to state 74
    OBJECTID        shift and go to state 61
    IF              shift and go to state 68
    WHILE           shift and go to state 42
    {               shift and go to state 75
    CASE            shift and go to state 47
    (               shift and go to state 52
    ~               shift and go to state 78
    NEW             shift and go to state 45
    ISVOID          shift and go to state 48
    NOT             shift and go to state 65
    INT_CONST       shift and go to state 49
    STR_CONST       shift and go to state 38
    BOOL_CONST      shift and go to state 44

    case_expr                      shift and go to state 39
    int                            shift and go to state 40
    dispatch                       shift and go to state 41
    un_op                          shift and go to state 43
    eq                             shift and go to state 46
    le                             shift and go to state 50
    sub                            shift and go to state 51
    neg                            shift and go to state 72
    isvoid                         shift and go to state 53
    lt                             shift and go to state 54
    bool                           shift and go to state 55
    comp                           shift and go to state 56
    mul                            shift and go to state 66
    ref                            shift and go to state 58
    parens                         shift and go to state 59
    string                         shift and go to state 60
    while_expr                     shift and go to state 62
    object                         shift and go to state 63
    new                            shift and go to state 64
    if_expr                        shift and go to state 69
    static_dispatch                shift and go to state 70
    expr                           shift and go to state 174
    bin_op                         shift and go to state 73
    plus                           shift and go to state 57
    div                            shift and go to state 67
    assign                         shift and go to state 76
    block                          shift and go to state 77

state 174

    (51) more_let -> , OBJECTID : TYPEID ASSIGN expr . more_let
    (32) dispatch -> expr . . OBJECTID ( actuals )
    (34) static_dispatch -> expr . @ TYPEID . OBJECTID ( actuals )
    (61) plus -> expr . + expr
    (62) sub -> expr . - expr
    (63) mul -> expr . * expr
    (64) div -> expr . / expr
    (65) lt -> expr . < expr
    (66) le -> expr . LE expr
    (67) eq -> expr . = expr
    (50) more_let -> . , OBJECTID : TYPEID more_let
    (51) more_let -> . , OBJECTID : TYPEID ASSIGN expr more_let
    (52) more_let -> . empty
    (84) empty -> .

    .               shift and go to state 96
    @               shift and go to state 91
    +               shift and go to state 92
    -               shift and go to state 94
    *               shift and go to state 93
    /               shift and go to state 95
    <               shift and go to state 97
    LE              shift and go to state 90
    =               shift and go to state 98
    ,               shift and go to state 152
    IN              reduce using rule 84 (empty -> .)

    empty                          shift and go to state 155
    more_let                       shift and go to state 175

state 175

    (51) more_let -> , OBJECTID : TYPEID ASSIGN expr more_let .

    IN              reduce using rule 51 (more_let -> , OBJECTID : TYPEID ASSIGN expr more_let .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for . in state 82 resolved as shift
WARNING: shift/reduce conflict for @ in state 82 resolved as shift
WARNING: shift/reduce conflict for + in state 82 resolved as shift
WARNING: shift/reduce conflict for - in state 82 resolved as shift
WARNING: shift/reduce conflict for * in state 82 resolved as shift
WARNING: shift/reduce conflict for / in state 82 resolved as shift
WARNING: shift/reduce conflict for < in state 82 resolved as shift
WARNING: shift/reduce conflict for LE in state 82 resolved as shift
WARNING: shift/reduce conflict for = in state 82 resolved as shift
WARNING: shift/reduce conflict for . in state 84 resolved as shift
WARNING: shift/reduce conflict for @ in state 84 resolved as shift
WARNING: shift/reduce conflict for + in state 84 resolved as shift
WARNING: shift/reduce conflict for - in state 84 resolved as shift
WARNING: shift/reduce conflict for * in state 84 resolved as shift
WARNING: shift/reduce conflict for / in state 84 resolved as shift
WARNING: shift/reduce conflict for < in state 84 resolved as shift
WARNING: shift/reduce conflict for LE in state 84 resolved as shift
WARNING: shift/reduce conflict for = in state 84 resolved as shift
WARNING: shift/reduce conflict for . in state 88 resolved as shift
WARNING: shift/reduce conflict for @ in state 88 resolved as shift
WARNING: shift/reduce conflict for + in state 88 resolved as shift
WARNING: shift/reduce conflict for - in state 88 resolved as shift
WARNING: shift/reduce conflict for * in state 88 resolved as shift
WARNING: shift/reduce conflict for / in state 88 resolved as shift
WARNING: shift/reduce conflict for < in state 88 resolved as shift
WARNING: shift/reduce conflict for LE in state 88 resolved as shift
WARNING: shift/reduce conflict for = in state 88 resolved as shift
WARNING: shift/reduce conflict for . in state 104 resolved as shift
WARNING: shift/reduce conflict for @ in state 104 resolved as shift
WARNING: shift/reduce conflict for + in state 104 resolved as shift
WARNING: shift/reduce conflict for - in state 104 resolved as shift
WARNING: shift/reduce conflict for * in state 104 resolved as shift
WARNING: shift/reduce conflict for / in state 104 resolved as shift
WARNING: shift/reduce conflict for < in state 104 resolved as shift
WARNING: shift/reduce conflict for LE in state 104 resolved as shift
WARNING: shift/reduce conflict for = in state 104 resolved as shift
WARNING: shift/reduce conflict for . in state 111 resolved as shift
WARNING: shift/reduce conflict for @ in state 111 resolved as shift
WARNING: shift/reduce conflict for + in state 111 resolved as shift
WARNING: shift/reduce conflict for - in state 111 resolved as shift
WARNING: shift/reduce conflict for * in state 111 resolved as shift
WARNING: shift/reduce conflict for / in state 111 resolved as shift
WARNING: shift/reduce conflict for < in state 111 resolved as shift
WARNING: shift/reduce conflict for LE in state 111 resolved as shift
WARNING: shift/reduce conflict for = in state 111 resolved as shift
WARNING: shift/reduce conflict for . in state 113 resolved as shift
WARNING: shift/reduce conflict for @ in state 113 resolved as shift
WARNING: shift/reduce conflict for + in state 113 resolved as shift
WARNING: shift/reduce conflict for - in state 113 resolved as shift
WARNING: shift/reduce conflict for * in state 113 resolved as shift
WARNING: shift/reduce conflict for / in state 113 resolved as shift
WARNING: shift/reduce conflict for < in state 113 resolved as shift
WARNING: shift/reduce conflict for LE in state 113 resolved as shift
WARNING: shift/reduce conflict for = in state 113 resolved as shift
WARNING: shift/reduce conflict for . in state 115 resolved as shift
WARNING: shift/reduce conflict for @ in state 115 resolved as shift
WARNING: shift/reduce conflict for + in state 115 resolved as shift
WARNING: shift/reduce conflict for - in state 115 resolved as shift
WARNING: shift/reduce conflict for * in state 115 resolved as shift
WARNING: shift/reduce conflict for / in state 115 resolved as shift
WARNING: shift/reduce conflict for < in state 115 resolved as shift
WARNING: shift/reduce conflict for LE in state 115 resolved as shift
WARNING: shift/reduce conflict for = in state 115 resolved as shift
WARNING: shift/reduce conflict for . in state 116 resolved as shift
WARNING: shift/reduce conflict for @ in state 116 resolved as shift
WARNING: shift/reduce conflict for + in state 116 resolved as shift
WARNING: shift/reduce conflict for - in state 116 resolved as shift
WARNING: shift/reduce conflict for * in state 116 resolved as shift
WARNING: shift/reduce conflict for / in state 116 resolved as shift
WARNING: shift/reduce conflict for < in state 116 resolved as shift
WARNING: shift/reduce conflict for LE in state 116 resolved as shift
WARNING: shift/reduce conflict for = in state 116 resolved as shift
WARNING: shift/reduce conflict for . in state 117 resolved as shift
WARNING: shift/reduce conflict for @ in state 117 resolved as shift
WARNING: shift/reduce conflict for + in state 117 resolved as shift
WARNING: shift/reduce conflict for - in state 117 resolved as shift
WARNING: shift/reduce conflict for * in state 117 resolved as shift
WARNING: shift/reduce conflict for / in state 117 resolved as shift
WARNING: shift/reduce conflict for < in state 117 resolved as shift
WARNING: shift/reduce conflict for LE in state 117 resolved as shift
WARNING: shift/reduce conflict for = in state 117 resolved as shift
WARNING: shift/reduce conflict for . in state 118 resolved as shift
WARNING: shift/reduce conflict for @ in state 118 resolved as shift
WARNING: shift/reduce conflict for + in state 118 resolved as shift
WARNING: shift/reduce conflict for - in state 118 resolved as shift
WARNING: shift/reduce conflict for * in state 118 resolved as shift
WARNING: shift/reduce conflict for / in state 118 resolved as shift
WARNING: shift/reduce conflict for < in state 118 resolved as shift
WARNING: shift/reduce conflict for LE in state 118 resolved as shift
WARNING: shift/reduce conflict for = in state 118 resolved as shift
WARNING: shift/reduce conflict for . in state 120 resolved as shift
WARNING: shift/reduce conflict for @ in state 120 resolved as shift
WARNING: shift/reduce conflict for + in state 120 resolved as shift
WARNING: shift/reduce conflict for - in state 120 resolved as shift
WARNING: shift/reduce conflict for * in state 120 resolved as shift
WARNING: shift/reduce conflict for / in state 120 resolved as shift
WARNING: shift/reduce conflict for < in state 120 resolved as shift
WARNING: shift/reduce conflict for LE in state 120 resolved as shift
WARNING: shift/reduce conflict for = in state 120 resolved as shift
WARNING: shift/reduce conflict for . in state 121 resolved as shift
WARNING: shift/reduce conflict for @ in state 121 resolved as shift
WARNING: shift/reduce conflict for + in state 121 resolved as shift
WARNING: shift/reduce conflict for - in state 121 resolved as shift
WARNING: shift/reduce conflict for * in state 121 resolved as shift
WARNING: shift/reduce conflict for / in state 121 resolved as shift
WARNING: shift/reduce conflict for < in state 121 resolved as shift
WARNING: shift/reduce conflict for LE in state 121 resolved as shift
WARNING: shift/reduce conflict for = in state 121 resolved as shift
WARNING: shift/reduce conflict for . in state 139 resolved as shift
WARNING: shift/reduce conflict for @ in state 139 resolved as shift
WARNING: shift/reduce conflict for + in state 139 resolved as shift
WARNING: shift/reduce conflict for - in state 139 resolved as shift
WARNING: shift/reduce conflict for * in state 139 resolved as shift
WARNING: shift/reduce conflict for / in state 139 resolved as shift
WARNING: shift/reduce conflict for < in state 139 resolved as shift
WARNING: shift/reduce conflict for LE in state 139 resolved as shift
WARNING: shift/reduce conflict for = in state 139 resolved as shift
